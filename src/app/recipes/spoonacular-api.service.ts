import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { AngularFireAuth } from '@angular/fire/auth';
import { AngularFirestore } from '@angular/fire/firestore';
import { Observable } from 'rxjs';
import { filter, map, shareReplay, switchMap } from 'rxjs/operators';
import notEmpty from '@grocerment-globals/not-empty-filter';
import { Spoonacular } from '@grocerment-models/spoonacular.model';

@Injectable()
export class SpoonacularApiService {

  private baseUrl = 'https://api.spoonacular.com';
  /** Reference to the soonacular collection */
  private readonly spoonacularCollectionRef$ = this.afAuth.user.pipe(
    filter( notEmpty ),
    map( user => this.firestore.collection<Spoonacular>('spoonacular') ),
    shareReplay(1),
  );
  /** spoonacular details stored in database */
  private readonly details$ = this.spoonacularCollectionRef$.pipe(
    switchMap( ref => ref.doc("details").get() ),
    map( document => document.exists ? document.data() : undefined ),
    shareReplay(1),
  );

  constructor(
    private readonly firestore: AngularFirestore,
    private readonly afAuth: AngularFireAuth,
    private readonly http: HttpClient,
  ) { }

  /** Fetches a list of receipies from spoonacular's API depeding on supplied ingredients */
  fetchRecipesByIngredients( params: RecipeByIngredientsParams ): Observable<FetchedRecipeByIngredients[]> {

    const url = new URL( '/recipes/findByIngredients', this.baseUrl );
    if ( !Array.isArray(params.ingredients) ) throw Error('No ingredients to search recipes with');

    return this.details$.pipe(
      switchMap( details => {

        const queryParams: Record<string,string> = {
          ingredients: params.ingredients.join(','),
        };

        if( !details?.apikey ) throw Error('Attempted to retrieve recipes from spoonacular without API key');
        else queryParams.apiKey = details.apikey;
        
        if( params.hasOwnProperty('number') && params.number != null ) queryParams.number = params.number.toString();
        if( params.hasOwnProperty('ranking') && params.ranking != null ) queryParams.ranking = params.ranking.toString();
        if( params.hasOwnProperty('limitLicense') && params.limitLicense != null ) queryParams.limitLicense = params.limitLicense.toString();
        if( params.hasOwnProperty('ignorePantry') && params.ignorePantry != null ) queryParams.ignorePantry = params.ignorePantry.toString();

        url.search = new URLSearchParams(queryParams).toString();

        return this.http.get<FetchedRecipeByIngredients[]>(url.toString());

      } ),
    );

  }

  /** Fetches a single recipe in full detail based on input ID */
  fetchRecipeById( id: number ): Observable<RecipeDetails> {

    if ( !id ) throw Error('No recipe ID suppied to retrieve');
    const url = new URL( `/recipes/${id}/information`, this.baseUrl );

    return this.details$.pipe(
      switchMap( details => {

        const queryParams: Record<string,string> = {
          includeNutrition: 'false',
        };

        if( !details?.apikey ) throw Error('Attempted to retrieve recipes from spoonacular without API key');
        else queryParams.apiKey = details.apikey;

        url.search = new URLSearchParams(queryParams).toString();
        
        return this.http.get<RecipeDetails>(url.toString());

      } ),
    );
  }

}

export interface RecipeByIngredientsParams {
  /** List of ingredients that the recipes should contain. */
  ingredients: string[]
  /** Maximum number of recipes to return (between 1 and 100). Defaults to 10. */
  number?: number
  /** Whether the recipes should have an open license that allows display with proper attribution. */
  limitLicense?: boolean
  /** Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. */
  ranking?: number
  /** Whether to ignore typical pantry items, such as water, salt, flour, etc. */
  ignorePantry?: boolean
}

// Generated by https://quicktype.io
export interface FetchedRecipeByIngredients {
  id:                    number;
  title:                 string;
  image:                 string;
  imageType:             ImageType;
  usedIngredientCount:   number;
  missedIngredientCount: number;
  missedIngredients:     Ingredient[];
  usedIngredients:       Ingredient[];
  unusedIngredients:     any[];
  likes:                 number;
}

export interface Ingredient {
  id:              number;
  amount:          number;
  unit:            string;
  unitLong:        string;
  unitShort:       string;
  aisle:           string;
  name:            string;
  original:        string;
  originalString:  string;
  originalName:    string;
  metaInformation: string[];
  meta:            string[];
  extendedName?:   string;
  image:           string;
}

export enum ImageType {
  Jpg = "jpg",
}

// Generated by https://quicktype.io

export interface RecipeDetails {
  id:                       number;
  title:                    string;
  image:                    string;
  imageType:                string;
  servings:                 number;
  readyInMinutes:           number;
  license:                  string;
  sourceName:               string;
  sourceUrl:                string;
  spoonacularSourceUrl:     string;
  aggregateLikes:           number;
  healthScore:              number;
  spoonacularScore:         number;
  pricePerServing:          number;
  analyzedInstructions:     any[];
  cheap:                    boolean;
  creditsText:              string;
  cuisines:                 any[];
  dairyFree:                boolean;
  diets:                    any[];
  gaps:                     string;
  glutenFree:               boolean;
  instructions:             string;
  ketogenic:                boolean;
  lowFodmap:                boolean;
  occasions:                any[];
  sustainable:              boolean;
  vegan:                    boolean;
  vegetarian:               boolean;
  veryHealthy:              boolean;
  veryPopular:              boolean;
  whole30:                  boolean;
  weightWatcherSmartPoints: number;
  dishTypes:                string[];
  extendedIngredients:      ExtendedIngredient[];
  summary:                  string;
  winePairing:              WinePairing;
}

export interface ExtendedIngredient {
  aisle:        string;
  amount:       number;
  consitency:   Consitency;
  id:           number;
  image:        string;
  measures:     Measures;
  meta:         string[];
  name:         string;
  original:     string;
  originalName: string;
  unit:         string;
}

export enum Consitency {
  Liquid = "liquid",
  Solid = "solid",
}

export interface Measures {
  metric: Metric;
  us:     Metric;
}

export interface Metric {
  amount:    number;
  unitLong:  string;
  unitShort: string;
}

export interface WinePairing {
  pairedWines:    string[];
  pairingText:    string;
  productMatches: ProductMatch[];
}

export interface ProductMatch {
  id:            number;
  title:         string;
  description:   string;
  price:         string;
  imageUrl:      string;
  averageRating: number;
  ratingCount:   number;
  score:         number;
  link:          string;
}
